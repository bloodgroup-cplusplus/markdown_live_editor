
    <html>
      <head><meta charset="UTF-8"><title>Markdown Preview</title></head>
      <body><h2><strong>Read vs Write Operations - Understanding the Flow</strong></h2>
<h3><strong>ğŸ¯ Challenge 2: The Library Rush</strong></h3>
<p><strong>Scenario:</strong> A library has 1000 students:</p>
<ul>
<li>950 students are browsing books (reading data)</li>
<li>50 students are checking out books (writing data)</li>
</ul>
<p><strong>Question:</strong> Which operation is more demanding on the library system?</p>
<p>Think about it:</p>
<ul>
<li>Reading is just looking at information</li>
<li>Writing requires updating records, checking availability, locking resources</li>
<li>Which needs more coordination?</li>
</ul>
<h3><strong>The Answer: Writes Are Much More Expensive!</strong></h3>
<p><strong>The fundamental truth:</strong> Reads are cheap, writes are expensive.</p>
<hr>
<h3><strong>ğŸ“š Understanding Read Operations</strong></h3>
<p><strong>What happens during a READ:</strong></p>
<pre><code class="language-sql">
 SELECT * FROM users WHERE username = 'alice';
</code></pre>
<p><strong>Behind the scenes:</strong></p>
<p>1. Find data location (using index if available) âš¡</p>
<p>2. Read from disk/memory ğŸ“–</p>
<p>3. Return result âœ“</p>
<p>No locks (in most cases)</p>
<p>No validation needed</p>
<p>No disk writes</p>
<p>Multiple reads can happen simultaneously</p>
<p><strong>Mental model:</strong> Reading is like looking at a museum painting - everyone can look at the same time, no one interferes with each other!</p>
<p><strong>Types of Reads:</strong></p>
<pre><code class="language-sql">
 SELECT \* FROM users WHERE username = 'alice';
</code></pre>
<p><strong>Read characteristics:</strong></p>
<ul>
<li>
<p>âœ… Fast and efficient</p>
</li>
<li>
<p>âœ… Can happen in parallel</p>
</li>
<li>
<p>âœ… Don't block other reads</p>
</li>
<li>
<p>âœ… Cheap to scale (add read replicas)</p>
</li>
<li>
<p>âŒ Can block writes (in some isolation levels)</p>
</li>
</ul>
<hr>
<h3><strong>âœï¸ Understanding Write Operations</strong></h3>
<p><strong>What happens during a WRITE:</strong></p>
<pre><code class="language-sql"> UPDATE users SET email = 'new@email.com' WHERE id = 123;
</code></pre>
<p><strong>Behind the scenes (so much more complex!):</strong></p>
<ol>
<li>
<p>BEGIN TRANSACTION ğŸ”„</p>
</li>
<li>
<p>Acquire LOCK on the row ğŸ”’</p>
</li>
<li>
<p>Read current data ğŸ“–</p>
</li>
<li>
<p>Validate constraints (unique, foreign keys, etc.) âœ“</p>
</li>
<li>
<p>Write to transaction log (WAL) ğŸ“</p>
</li>
<li>
<p>Update indexes ğŸ—‚ï¸</p>
</li>
<li>
<p>Write actual data change ğŸ’¾</p>
</li>
<li>
<p>Release locks ğŸ”“</p>
</li>
<li>
<p>COMMIT transaction âœ…</p>
</li>
</ol>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764481458/214_w8h8ne.png" alt="img1"></p>
<p>Blocks concurrent writes to same row</p>
<p>Requires validation</p>
<p>Multiple disk writes</p>
<p>Slower than reads</p>
<p><strong>Mental model:</strong> Writing is like editing a shared Google Doc - only one person can edit a specific paragraph at a time, changes must be saved, version history updated, etc.</p>
<p><strong>Types of Writes:</strong></p>
<p>INSERT (simplest write):</p>
<pre><code class="language-sql">INSERT INTO users (name, email) VALUES ('Bob', 'bob@email.com');
</code></pre>
<p>Must:- Generate new ID</p>
<p>Check constraints (email unique?)</p>
<p>Update indexes</p>
<p>Write to log</p>
<p>UPDATE (complex write):</p>
<pre><code class="language-sql">UPDATE products SET price = 99.99 WHERE category = 'Electronics';
</code></pre>
<p>Must:</p>
<ul>
<li>
<p>Find all matching rows</p>
</li>
<li>
<p>Lock them</p>
</li>
<li>
<p>Update each one</p>
</li>
<li>
<p>Update all relevant indexes</p>
</li>
<li>
<p>Maintain consistency</p>
<p>DELETE (most complex):</p>
<pre><code class="language-sql">
DELETE FROM users WHERE id = 123;
</code></pre>
<p>Must:</p>
<p>Check foreign key constraints (does anything reference this?)</p>
<p>Lock the row</p>
<p>Remove from indexes</p>
<p>Mark as deleted</p>
<p>Handle cascade deletes</p>
</li>
</ul>
<p><strong>Write characteristics:</strong></p>
<ul>
<li>
<p>âŒ Slower than reads</p>
</li>
<li>
<p>âŒ Require locks (blocking)</p>
</li>
<li>
<p>âŒ Multiple validation steps</p>
</li>
<li>
<p>âŒ Multiple disk writes</p>
</li>
<li>
<p>âŒ Harder to scale</p>
</li>
<li>
<p>âœ… Ensure data integrity</p>
</li>
</ul>
<hr>
<h3><strong>ğŸ“Š The 80/20 Rule (or 95/5 in reality!)</strong></h3>
<p><strong>Real-world application traffic:</strong></p>
<p>ğŸ“Š Typical Web Application:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764481458/215_rxilqb.png" alt="img2"></p>
<p>Examples:</p>
<p>- Social media: 99% reading posts, 1% creating posts</p>
<p>- E-commerce: 95% browsing, 5% purchasing</p>
<p>- News sites: 99.9% reading, 0.1% commenting</p>
<p><strong>Why this matters for architecture:</strong></p>
<p><strong>Read-Heavy Application (like Twitter):</strong></p>
<p>Strategy: Optimize for reads!</p>
<p>- Use caching heavily (Redis, Memcached)</p>
<p>- Add read replicas</p>
<p>- Denormalize data for faster reads</p>
<p>- Use CDNs for static content</p>
<p><strong>Write-Heavy Application (like logging systems):</strong></p>
<p>Strategy: Optimize for writes!</p>
<p>- Batch writes together</p>
<p>- Use write-optimized databases</p>
<p>- Async processing</p>
<p>- Eventual consistency</p>
<hr>
<h3><strong>ğŸ® Interactive Exercise: Read or Write?</strong></h3>
<p><strong>Classify these operations:</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Read or Write?</th>
<th>Why?</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SELECT COUNT(*) FROM users</code></td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td><code>UPDATE users SET last_login = NOW() WHERE id = 1</code></td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td><code>SELECT * FROM posts ORDER BY created_at</code></td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td><code>INSERT INTO logs (message) VALUES ('error')</code></td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
<p><strong>Think about each one...</strong></p>
<p><strong>Answers:</strong></p>
<ol>
<li>
<p><strong>READ</strong> - Counting doesn't modify data</p>
</li>
<li>
<p><strong>WRITE</strong> - Modifying data, requires transaction, locks</p>
</li>
<li>
<p><strong>READ</strong> - Just retrieving and sorting data</p>
</li>
<li>
<p><strong>WRITE</strong> - Adding new data, requires transaction</p>
</li>
</ol>
<hr>
<h3><strong>ğŸ”¥ Performance Comparison: Real Numbers</strong></h3>
<p><strong>Scenario: Database with 1 million users</strong></p>
<p><strong>Read Operation:</strong></p>
<pre><code class="language-sql">
SELECT * FROM users WHERE id = 12345;
</code></pre>
<p>Time: 0.5-2ms âš¡
Disk I/O: 1 read
Locks: None (Read Committed)
Concurrent: Unlimited simultaneous reads</p>
<p><strong>Write Operation:</strong></p>
<pre><code class="language-sql">
UPDATE users SET last_name = 'Smith' WHERE id = 12345;
</code></pre>
<p>Time: 5-50ms â±ï¸
Disk I/O: 3-5 writes (data, log, indexes)
Locks: Row-level lock ğŸ”’
Concurrent: Blocks other writes to same row
Validation: Check constraints, update indexes</p>
<p><strong>Visual comparison:</strong></p>
<p>READ:  âš¡ â”€â”€â”€â”€âœ“ (Fast! One hop)</p>
<p>Write is 10-25x slower than read!</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764481458/213_cfax8z.png" alt="img3"></p>
<hr>
<h3><strong>ğŸš€ Optimization Strategies</strong></h3>
<p><strong>For Read-Heavy Systems:</strong></p>
<p><strong>1. Caching (we shall learn more about caching in the upcoming sections)</strong></p>
<p>First request:
User â†’ Database â†’ 50ms â±ï¸</p>
<p>With Cache:
User â†’ Cache â†’ 1ms âš¡
(50x faster!)</p>
<p>Only hit database on cache miss</p>
<p><strong>2. Read Replicas</strong> (read replicas will be discussed in upcoming lessons as well)</p>
<p>Primary Database (handles writes)
â†“ (replicates to)
Read Replica 1  Read Replica 2  Read Replica 3
â†“               â†“               â†“
Users          Users           Users</p>
<p>Distribute read load across replicas!</p>
<p><strong>3. Indexing</strong></p>
<p>Without index: Scan 1,000,000 rows â±ï¸</p>
<pre><code class="language-sql">
SELECT * FROM users WHERE email = 'alice@email.com';
</code></pre>
<p>With index: Jump to specific row âš¡</p>
<pre><code class="language-sql">
CREATE INDEX idx\_email ON users(email);
</code></pre>
<p><strong>For Write-Heavy Systems:</strong></p>
<p><strong>1. Batch Writes</strong></p>
<p>| // Bad example:</p>
<p>1000 individual writes</p>
<pre><code class="language-javascript">for (let i = 0; i &lt; 1000; i++) {

  await db.query('INSERT INTO logs (message) VALUES (?)', \[msg[i]]);}

  // Time: 1000 Ã— 5ms = 5000ms ğŸ˜°
</code></pre>
<p>// Good: 1 batched write</p>
<pre><code class="language-javascript">await db.query(  'INSERT INTO logs (message) VALUES (?), (?), ... (all 1000)',  messages);

// Time: 50ms âš¡ (100x faster\!)
</code></pre>
<p><strong>2. Async Processing</strong></p>
<p>User Action (POST /order)
â†“</p>
<p>Quick Response: &quot;Order received!&quot; âœ…
â†“</p>
<p>Background Job Queue ğŸ“‹
â†“</p>
<p>Process writes asynchronously</p>
<p><strong>3. Write-Optimized Storage</strong></p>
<p>Traditional Database: Update in place</p>
<p>- Read old value</p>
<p>- Modify</p>
<p>- Write back</p>
<p>- Update indexes</p>
<p>(Slow! Many disk seeks)</p>
<p>Log-Structured Storage: Append only</p>
<p>- Just write new entry at end</p>
<p>- Never modify existing data</p>
<p>- Periodically compact</p>
<p>(Fast! Sequential writes)</p>
<hr>
<h3><strong>ğŸ¯ Mental Models Summary</strong></h3>
<p><strong>Reading = Looking at a book</strong></p>
<ul>
<li>Many people can look at the same time</li>
<li>No permission needed</li>
<li>Fast and easy</li>
<li>Doesn't change anything</li>
</ul>
<p><strong>Writing = Editing a shared document</strong></p>
<ul>
<li>Need to coordinate with others</li>
<li>Requires permission (locks)</li>
<li>Must validate changes</li>
<li>Changes need to be saved</li>
<li>Slower and more complex</li>
</ul>
<p><strong>Key Insight:</strong> Design your application architecture around the read/write ratio! Most applications are read-heavy, so optimize for reads first.</p>
</body>
    </html>