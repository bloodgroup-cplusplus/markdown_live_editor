
    <html>
      <head><meta charset="UTF-8"><title>Markdown Preview</title></head>
      <body><h2><strong>Cache Hit vs Cache Miss - The Performance Game</strong></h2>
<h3><strong>üéØ Challenge 2: The Book Detective</strong></h3>
<p><strong>Scenario:</strong> You're looking for a book in a library:</p>
<p><strong>Situation A:</strong> You check the front desk ‚Üí Book is there! ‚Üí Take it (10 seconds)</p>
<p><strong>Situation B:</strong> You check the front desk ‚Üí Book is NOT there ‚Üí Go to storage room ‚Üí Search shelves ‚Üí Find it ‚Üí Bring to front (15 minutes)</p>
<p><strong>Question:</strong> Which situation is faster? What's the speed difference?</p>
<h3><strong>The Answer: Cache Hit vs Cache Miss!</strong></h3>
<p><strong>Cache Hit:</strong> Data found in cache (Situation A) - Fast! ‚ö°</p>
<p><strong>Cache Miss:</strong> Data not in cache, must fetch from source (Situation B) - Slow! ‚è±Ô∏è</p>
<hr>
<h3><strong>üìä Understanding Cache Hits and Misses</strong></h3>
<p><strong>Visual flow:</strong></p>
<p><strong><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764506120/218_aowgpl.png" alt="img1"></strong></p>
<hr>
<h3><strong>üéÆ Real-World Example: Video Streaming</strong></h3>
<p><strong>Say you are watching &quot;Stranger Things&quot; on Netflix</strong></p>
<p><strong>And end up being the first  viewer in your city (Cache Miss):</strong></p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764506120/220_vw3yz2.png" alt="img2"></p>
<p>The diagram shows how video is fetched from the original server and then stored in the cache</p>
<p><strong>Now the second viewer of ‚Äústranger things ‚Äú in your city  access netflix to experience video stream faster as it was cached :</strong></p>
<p><strong><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764506120/219_owidw1.png" alt="img3"></strong></p>
<hr>
<h3><strong>üìà Cache Hit Ratio: The Success Metric</strong></h3>
<p><strong>Formula:</strong></p>
<p><strong>Cache Hit Ratio = Cache Hits / Total Requests √ó 100%</strong></p>
<p>Example:
- 1000 requests
- 850 cache hits
- 150 cache misses</p>
<p>Hit Ratio = 850/1000 = 85%</p>
<p><strong>What different ratios mean:</strong></p>
<p>95-99% Hit Ratio: üåü Excellent!
- Most requests served from cache
- Minimal database load
- Great user experience</p>
<p>80-94% Hit Ratio: ‚úÖ Good
- Decent caching effectiveness
- Room for improvement
- Database still moderately busy</p>
<p>50-79% Hit Ratio: ‚ö†Ô∏è Needs Work
- Half requests hitting database
- Cache strategy needs review
- High database load</p>
<p>Below 50% Hit Ratio: ‚ùå Poor
- Cache not effective
- Might be caching wrong data
- Consider removing cache (overhead without benefit)</p>
<hr>
<h3><strong>üîç Why Cache Misses Happen</strong></h3>
<p><strong>1. Cold Start (Empty Cache)</strong></p>
<p><strong>In our netflix example for ‚Äústranger things ‚Äú the application had  just started</strong>
<strong>Cache was empty</strong></p>
<p>First request for each item = Miss</p>
<p>Example:
Request 1 (Product A): Miss ‚ùå ‚Üí Load from DB
Request 2 (Product A): Hit ‚úÖ ‚Üí From cache
Request 3 (Product B): Miss ‚ùå ‚Üí Load from DB
Request 4 (Product B): Hit ‚úÖ ‚Üí From cache</p>
<p><strong>2. Cache Expiration (TTL)</strong></p>
<p><strong>Say a phone on amazon has a bumper offer on Christmas but just for 5 minutes</strong></p>
<p>Price data cached at 10:00 AM (TTL: 5 minutes)
Request at 10:04 AM: Hit ‚úÖ
Request at 10:06 AM: Miss ‚ùå (Expired!)
‚Üí Refresh from database</p>
<p><strong>3. Cache Eviction (Full Cache)</strong></p>
<p><strong>Say we have a current cache size of 100 items and all of them get filled up</strong></p>
<p>Cache capacity: 100 items
Currently: 100 items (full!)
New item requested: Must remove old item
‚Üí Miss for the evicted item</p>
<p><strong>4. Cache Invalidation (Data Changed)</strong></p>
<p>Product price changes in database
Cache entry invalidated (removed)
Next request: Miss ‚ùå ‚Üí Fetch fresh data</p>
<hr>
<h3><strong>üíª Code Example: Tracking Hits and Misses</strong></h3>
<pre><code class="language-javascript"> class CacheTracker {
      constructor() {
        this.hits = 0;
        this.misses = 0;
        this.cache = {}
        }
        get(key) {
          if (this.cache[key]) {
            this.hits++;
            console.log(`‚úÖ Cache HIT for ${key}`);
            return this.cache[key]
            }
          else {
            this.misses++;
            console.log(`‚ùå Cache MISS for ${key}`);     return null;
            }
        }
        set(key, value) {
          this.cache[key] = value;
        }
        getHitRatio() {
          const total = this.hits + this.misses;
          return total &gt; 0 ? (this.hits/total * 10).toFixed(2) : 0;
        }
        getStats() {
          return {
            hits: this.hits,
            misses: this.misses,
            hitRatio: `${this.getHitRatio()}`
          };
        }
    }
  // Usage example
  const cache = new CacheTracker();

  // First request  Cache Miss

  cache.get('user:123');  // ‚ùå Miss

  const user = await db.getUser(123);

  cache.set('user:123', user);

  // Second request - Cache Hit

  cache.get('user:123');

  // ‚úÖ Hit

 // Third request Different user  Cache Miss

 cache.get('user:456');  // ‚ùå Miss

 console.log(cache.getStats())

 // { hits: 1, misses: 2, hitRatio: '33.33%' } |

</code></pre>
<hr>
<h3><strong>üé™ Interactive Exercise: Calculate Hit Ratio</strong></h3>
<p><strong>Scenario: Let us consider an E-commerce website over 1 hour</strong></p>
<p>The homepage (popular):
Let‚Äôs say we have 10,000 requests
The First request: Misses the essential data it  loads from DB (cache miss)  and stores it into the cache
Now for the next  9,999 requests: The content is served  from cache</p>
<p>Hits: 9,999 | Misses: 1</p>
<p>Product page (100 different products):
Let us say each product is  requested 50 times
Total requests: 5,000 (100 * 50)
First request  for every  product  is a cache miss since its not being fetched yet  (100 misses)
Subsequent requests: Hits (4,900 hits)</p>
<p>Hits: 4,900 | Misses: 100</p>
<p>User profiles (1,000 different users):</p>
<p>Each user profile viewed 2 times
Total requests: 2,000
First view: Miss (1,000 misses)
Second view: Hit (1,000 hits)
Hits: 1,000 | Misses: 1,000</p>
<p><strong>Question:</strong> What's the overall cache hit ratio?</p>
<p><strong>Calculate:</strong></p>
<p>Total Hits: 9,999 + 4,900 + 1,000 = 15,899
Total Misses: 1 + 100 + 1,000 = 1,101
Total Requests: 15,899 + 1,101 = 17,000</p>
<p>Hit Ratio = 15,899 / 17,000 = 93.52% üåü</p>
<p>This is excellent! Homepage caching is very effective.</p>
<hr>
<h3><strong>üöÄ Optimizing for Cache Hits</strong></h3>
<p><strong>Strategy 1: Cache Warming (Pre-populate)</strong></p>
<p>In cache warming you don‚Äôt wait for the first request instead we already add the data to the cache</p>
<p>For instance netflix might be aware the people are going to watch ‚Äústranger things‚Äù, ‚Äúsquid games‚Äù so they can prepopulate the cache with videos</p>
<p>// Don't wait for first request - warm cache at startup</p>
<pre><code class="language-javascript">
async function warmCache() {

 console.log('Warming cache...');

 // Load popular items into cache

 const popularProducts = await db.query('SELECT * FROM products ORDER BY views DESC LIMIT 100'  );

 popularProducts.forEach(product =&gt; {

   cache.set(`product:${product.id}`, product);  });

   console.log('Cache warmed with 100 popular products\!')

  }
   // Run at application startup
   warmCache()

</code></pre>
<p><strong>Strategy 2: Longer TTL for Stable Data</strong></p>
<p>Say we are accessing an ecommerce website like Amazon the content on the homepage changes daily based on recommendation or say there is a Black Friday Sale or Halloween Sale or Big Billion Sale (India) the page content has to show content with new offers so homepage content has to be changing based on day, based on time based on the user gender, age, recommendation and all such factors</p>
<pre><code class="language-javascript">// Homepage content (changes daily)

cache.set('homepage', data, { ttl: 3600 });  // 1 hour

/*The product catalog changes on a weekly basis so we can keep the cache time upto 24 hours*/

// Product catalog (changes weekly)

cache.set('products', data, { ttl: 86400 });  // 24 hours

/*Details such as user profile, user name, user photo changes rarely on an ecomm site so we can keep the ttl for such content longer say even a month
*/


cache.set(`user:${id}`, data, { ttl: 86400 * 30 });

// 1 month
</code></pre>
<p><strong>Strategy 3: Predictive Caching</strong></p>
<p>Say a  user views product A (a phone)
Now he/she is very likely to view related Products B (phone cover), C (tempered glass), D (charging brick)
So products B,C,D could be pre-fetched and cached!</p>
<pre><code class="language-js">async function cacheRelatedProducts(productId) {

  const related = await db.query( 'SELECT * FROM products WHERE category = (SELECT category FROM products WHERE id = ?)', [productId]  );
  related.forEach(product =&gt; {

  cache.set(`product:${product.id}`, product);  })

  }
</code></pre>
<hr>
<h3><strong>üìä Monitoring Cache Performance</strong></h3>
<p>Key metrics to track:</p>
<ul>
<li>Average Response Time</li>
<li>Cache Size</li>
<li>Eviction Rate</li>
<li>Staleness</li>
<li>Alert Thresholds</li>
<li>Eviction Rate</li>
</ul>
<pre><code class="language-js"> const metrics = {

    // Hit ratio (most important!)

  hitRatio: (hits / (hits + misses)) * 100,

  // Average response time

  avgHitTime: 2,    // ms (from cache)

  avgMissTime: 150, // ms (from database)

  // Cache size

  itemsInCache: 5000,

  memoryUsed: '500 MB',

  // Eviction rate

  evictionsPerHour: 100,

  // Staleness

  avgItemAge: 300  // seconds
  }

  // Alert thresholds

  if (hitRatio &lt; 80) {

    alert('Low cache hit ratio Review caching strategy')

  }
  if (evictionsPerHour &gt; 1000) {

    alert('High eviction rate! Consider increasing cache size');
  }

---
</code></pre>
</body>
    </html>