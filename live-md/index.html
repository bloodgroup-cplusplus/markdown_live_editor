
    <html>
      <head><meta charset="UTF-8"><title>Markdown Preview</title></head>
      <body><h2><strong>Load Balancing Basics - The Traffic Director</strong></h2>
<h3><strong>ğŸ¯ Challenge 4: The Restaurant Host Problem</strong></h3>
<p><strong>Scenario:</strong> You own a restaurant with 5 identical dining rooms. Customers arrive at the entrance.</p>
<p><strong>Without a host:</strong></p>
<p>Entrance
â”‚</p>
<pre><code>        â–¼
</code></pre>
<p>Room 1: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (packed, 30 min wait)</p>
<p>Room 2: â–ˆâ–ˆâ–ˆâ–ˆ         (some people)</p>
<p>Room 3: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (packed)</p>
<p>Room 4: â–ˆâ–ˆ           (almost empty!)</p>
<p>Room 5: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ (packed)</p>
<p>Problem: Customers just pick random rooms!
Result: Long waits, unhappy customers, empty tables</p>
<p><strong>With a smart host:</strong></p>
<p>Entrance</p>
<p>â”‚</p>
<p>â–¼</p>
<p>Host (sees all rooms, directs customers smartly)</p>
<p>â”œâ”€â†’ Room 1: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (balanced)</p>
<p>â”œâ”€â†’ Room 2: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (balanced)</p>
<p>â”œâ”€â†’ Room 3: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (balanced)</p>
<p>â”œâ”€â†’ Room 4: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (balanced)</p>
<p>â””â”€â†’ Room 5: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (balanced)</p>
<p>Result: No waits, happy customers, efficient!</p>
<p><strong>This is exactly what a Load Balancer does!</strong></p>
<hr>
<h3><strong>ğŸ—ï¸ What is Load Balancing?</strong></h3>
<p><strong>Definition:</strong> A load balancer is like a smart traffic director that distributes incoming requests across multiple servers.</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771695/262_rajp5f.png" alt="img1"></p>
<p>All servers: Happy and balanced!</p>
<p><strong>Key Insight:</strong> Load balancers prevent any single server from being overwhelmed!</p>
<hr>
<h3><strong>ğŸ® Interactive Exercise: Load Balancing Algorithms</strong></h3>
<p><strong>Scenario:</strong> You have 3 servers. 9 requests arrive. How do you distribute them?</p>
<p>Let's explore different strategies:</p>
<h4><strong>Algorithm 1: Round Robin ğŸ”„</strong></h4>
<p><strong>How it works:</strong> &quot;Take turns, like dealing cards&quot;</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771695/254_ggpk1u.png" alt="img2"></p>
<p>Perfect equality!</p>
<p><strong>Pros:</strong> Simple, fair, easy to implement <strong>Cons:</strong> Doesn't consider server load or speed</p>
<p><strong>Real-world example:</strong> Like handing out homework to students in seat order</p>
<hr>
<h4><strong>Algorithm 2: Least Connections ğŸ“Š</strong></h4>
<p><strong>How it works:</strong> &quot;Send to whoever is least busy right now&quot;</p>
<p>Starting state:</p>
<p>Server 1: 2 active connections</p>
<p>Server 2: 5 active connections</p>
<p>Server 3: 1 active connection</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764773305/load_balance_zj4bnd.png" alt="img3"></p>
<p>New request arrives:</p>
<p>â†’ Check all servers</p>
<p>â†’ Server 3 has fewest connections (1)</p>
<p>â†’ Send request to Server 3!</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771696/258_e36d0v.png" alt="img4"></p>
<p><strong>Pros:</strong> Accounts for different request durations</p>
<p><strong>Cons:</strong> Slightly more complex, needs to track connections</p>
<p><strong>Real-world example:</strong> Like a grocery store checkout - you join the shortest line!</p>
<hr>
<h4><strong>Algorithm 3: Weighted Distribution âš–ï¸</strong></h4>
<p><strong>How it works:</strong> &quot;Better servers get more work&quot;</p>
<p>Server setup:</p>
<p>Server 1: Power rating 5 (newest, most powerful)</p>
<p>Server 2: Power rating 3 (medium)</p>
<p>Server 3: Power rating 2 (older, slower)</p>
<p>Total power: 10</p>
<p>Distribution ratio: 5:3:2</p>
<p>For 100 requests:</p>
<p>Server 1 gets: 50 requests (50%)</p>
<p>Server 2 gets: 30 requests (30%)</p>
<p>Server 3 gets: 20 requests (20%)</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771695/256_ax9fjr.png" alt="img5"></p>
<p><strong>Pros:</strong> Utilizes hardware differences efficiently</p>
<p><strong>Cons:</strong> Requires knowing server capabilities</p>
<p><strong>Real-world example:</strong> Like a restaurant assigning more tables to experienced waiters</p>
<hr>
<h4><strong>Algorithm 4: IP Hash ğŸ”</strong></h4>
<p><strong>How it works:</strong> &quot;Same client always goes to same server&quot;</p>
<p>How hashing works:</p>
<p>User IP: 192.168.1.100</p>
<p>â†’ Hash function: hash(192.168.1.100) = 347</p>
<p>â†’ 347 % 3 = 2  (modulo number of servers)</p>
<p>â†’ Always routes to Server 2!</p>
<p>Same user's next request:</p>
<p>â†’ hash(192.168.1.100) = 347  (same!)</p>
<p>â†’ 347 % 3 = 2</p>
<p>â†’ Server 2 again!</p>
<p>Different user IP: 192.168.1.101</p>
<p>â†’ hash(192.168.1.101) = 892</p>
<p>â†’ 892 % 3 = 1</p>
<p>â†’ Routes to Server 1</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771695/261_cklgsr.png" alt="img6">)</p>
<p><strong>Pros:</strong></p>
<ul>
<li>Session persistence (user's data cached on one server)</li>
<li>Predictable routing</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li>Uneven distribution if many users from same IP range</li>
<li>Server failure requires rehashing</li>
</ul>
<p><strong>Real-world example:</strong> Like having a regular doctor - you always see the same one who knows your history</p>
<hr>
<h3><strong>ğŸ’¡ Types of Load Balancers: Layer 4 vs Layer 7</strong></h3>
<p>ğŸ”Œ LAYER 4 (Network Load Balancer)</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p>Works at: TCP/UDP level</p>
<p>Sees: IP addresses, ports</p>
<p>Fast: Very (just forwards packets)</p>
<p>Smart: Not very</p>
<p>Example decision:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771696/257_ikxhju.png" alt="img7"></p>
<p>Use when: Raw speed needed, simple TCP routing</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>ğŸŒ LAYER 7 (Application Load Balancer)</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p>Works at: HTTP/HTTPS level</p>
<p>Sees: URLs, headers, cookies, content</p>
<p>Fast: Slower (must read HTTP)</p>
<p>Smart: Very!</p>
<p>Example decision:
&quot;This request is for /api/users&quot;
â†’ Route to API servers</p>
<p>&quot;This request is for /images/cat.jpg&quot;
â†’ Route to image servers</p>
<pre><code>  Internet
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Layer 7 â”‚  &quot;GET /api/users&quot;
â”‚   LB    â”‚  â†’ Route to API cluster
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚       &quot;GET /static/logo.png&quot;
     â”‚       â†’ Route to CDN servers
     â”‚
â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
â–¼          â–¼
</code></pre>
<p>[API Servers] [Static Servers]</p>
<p>Use when: Need smart routing by content</p>
<p><strong>Real-world comparison:</strong></p>
<ul>
<li>
<p><strong>Layer 4:</strong> Like a highway toll booth - just directs cars, doesn't care what's inside</p>
</li>
<li>
<p><strong>Layer 7:</strong> Like a smart receptionist - reads your request and directs you to the right department</p>
</li>
</ul>
<h3><strong>ğŸš¨ Common Misconception: &quot;Load Balancers Never Fail&quot;</strong></h3>
<p><strong>You might think:</strong> &quot;Great! Load balancer solves everything!&quot;</p>
<p><strong>The Reality:</strong> Load balancers themselves can fail or become bottlenecks!</p>
<p><strong>The Solution: Multiple Load Balancers!</strong></p>
<p>âŒ SINGLE LOAD BALANCER (Risky!)</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771696/257_ikxhju.png" alt="img8"></p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ… REDUNDANT LOAD BALANCERS (Safe!)</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771695/255_i2kk9d.png" alt="img9"></p>
<p>Safety: If LB 1 fails, LB 2 continues!</p>
<hr>
<h3><strong>ğŸª Real-World Load Balancing Architecture</strong></h3>
<p><strong>Let's see how a real company like Netflix might structure their load balancing:</strong></p>
<p>ğŸŒ GLOBAL ARCHITECTURE</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1764771696/260_rfic9f.png" alt="img10"></p>
<p>Each zone has:</p>
<p>â”œâ”€ Layer 4 Load Balancer (Network LB) â† Third layer: TCP routing</p>
<p>â”œâ”€ 50+ Web Servers</p>
<p>â”œâ”€ 20+ API Servers</p>
<p>â””â”€ 10+ Database Read Replicas</p>
<p><strong>Why multiple layers?</strong></p>
<ol>
<li>
<p><strong>DNS Layer:</strong> Routes by geography (latency optimization)</p>
</li>
<li>
<p><strong>Application Layer (L7):</strong> Routes by URL path, HTTP headers</p>
</li>
<li>
<p><strong>Network Layer (L4):</strong> Raw TCP connection distribution</p>
</li>
</ol>
<hr>
<h3><strong>ğŸ” Investigation: What Happens When a Server Dies?</strong></h3>
<p><strong>Scenario:</strong> You have 4 servers behind a load balancer. Server 3 crashes.</p>
<p><strong>Without Health Checks:</strong></p>
<p>Load Balancer: &quot;Round robin time!&quot;</p>
<p>Request 1 â†’ Server 1 âœ… (works)</p>
<p>Request 2 â†’ Server 2 âœ… (works)</p>
<p>Request 3 â†’ Server 3 âŒ (DEAD! User sees error)</p>
<p>Request 4 â†’ Server 4 âœ… (works)</p>
<p>Request 5 â†’ Server 1 âœ… (works)</p>
<p>Request 6 â†’ Server 2 âœ… (works)</p>
<p>Request 7 â†’ Server 3 âŒ (STILL DEAD! Another error)</p>
<p>Result: 25% of requests fail! ğŸ˜¡</p>
<p><strong>With Health Checks (Smart!):</strong></p>
<p>Health Check Configuration:</p>
<p>- Check every 10 seconds</p>
<p>- Send HTTP GET to /health</p>
<p>- Expect 200 OK response</p>
<p>- If fails 3 times â†’ Mark unhealthy</p>
<p>Timeline:
10:00:00 - Server 3 crashes</p>
<p>10:00:10 - Health check fails (1/3)</p>
<p>10:00:20 - Health check fails (2/3)</p>
<p>10:00:30 - Health check fails (3/3) â†’ REMOVED!</p>
<p>Load Balancer: &quot;Server 3 is out! Skip it!&quot;</p>
<p>Request 1 â†’ Server 1 âœ…</p>
<p>Request 2 â†’ Server 2 âœ…</p>
<p>Request 3 â†’ Server 4 âœ… (skipped dead Server 3!)</p>
<p>Request 4 â†’ Server 1 âœ…</p>
<p>Request 5 â†’ Server 2 âœ…</p>
<p>Result: 0% failures! ğŸ‰</p>
<p>10:05:00 - Server 3 comes back online
10:05:10 - Health check succeeds (1/3)
10:05:20 - Health check succeeds (2/3)
10:05:30 - Health check succeeds (3/3) â†’ ADDED BACK!</p>
<p>Load Balancer: &quot;Welcome back, Server 3!&quot;</p>
<p><strong>Key Insight:</strong> Health checks are CRITICAL for reliability!</p>
<hr>
<hr>
<h3><strong>ğŸ¯ Decision Game: Choose Your Algorithm</strong></h3>
<p><strong>For each scenario, pick the best load balancing algorithm:</strong></p>
<p><strong>Scenario A:</strong> Simple website, all servers identical</p>
<p><strong>Scenario B:</strong> Video encoding - jobs take 5 seconds to 5 minutes</p>
<p><strong>Scenario C:</strong> Shopping cart - need same user to hit same server</p>
<p><strong>Scenario D:</strong> 1 new powerful server + 2 older slower servers</p>
<p><strong>Scenario E:</strong> API with completely independent requests</p>
<p><strong>Think carefully...</strong></p>
<hr>
<p><strong>ANSWERS:</strong></p>
<p>Scenario A: ROUND ROBIN âœ“</p>
<p>Why: Servers identical, simple is best</p>
<p>Scenario B: LEAST CONNECTIONS âœ“</p>
<p>Why: Job duration varies widely, need dynamic balancing</p>
<p>Scenario C: IP HASH âœ“</p>
<p>Why: Session persistence required for cart data</p>
<p>Scenario D: WEIGHTED âœ“</p>
<p>Why: Different server capabilities</p>
<p>Config: New server weight=5, old servers weight=2 each</p>
<p>Scenario E: ROUND ROBIN or RANDOM âœ“</p>
<p>Why: Stateless, any algorithm works fine</p>
<hr>
<h3><strong>ğŸª The Complete Picture: Load Balancer Features</strong></h3>
<p>MODERN LOAD BALANCER CAPABILITIES</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p>âœ… Traffic Distribution</p>
<p>â”œâ”€ Round Robin</p>
<p>â”œâ”€ Least Connections</p>
<p>â”œâ”€ Weighted</p>
<p>â””â”€ IP Hash</p>
<p>âœ… Health Monitoring</p>
<p>â”œâ”€ HTTP health checks</p>
<p>â”œâ”€ TCP health checks</p>
<p>â”œâ”€ Custom health endpoints</p>
<p>â””â”€ Automatic server removal/re-addition</p>
<p>âœ… SSL/TLS Termination</p>
<p>â”œâ”€ Handle HTTPS encryption</p>
<p>â”œâ”€ Decrypt at load balancer</p>
<p>â””â”€ Send plain HTTP to backend
(reduces server CPU load)</p>
<p>âœ… Sticky Sessions</p>
<p>â”œâ”€ Cookie-based routing</p>
<p>â””â”€ Keep user on same server</p>
<p>âœ… Rate Limiting</p>
<p>â”œâ”€ Protect from DDoS</p>
<p>â””â”€ Throttle aggressive clients</p>
<p>âœ… Geographic Routing</p>
<p>â”œâ”€ Route EU users to EU servers</p>
<p>â””â”€ Minimize latency</p>
<p>âœ… Content-Based Routing</p>
<p>â”œâ”€ /api/* â†’ API servers</p>
<p>â”œâ”€ /images/* â†’ Image servers</p>
<p>â””â”€ /admin/* â†’ Admin servers</p>
<p>âœ… Metrics &amp; Logging</p>
<p>â”œâ”€ Request counts</p>
<p>â”œâ”€ Response times</p>
<p>â””â”€ Error rates</p>
<hr>
<h3><strong>ğŸ”‘ Key Takeaways: Load Balancing</strong></h3>
<p>ğŸ“ REMEMBER:</p>
<p>â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•</p>
<p>1ï¸âƒ£ Load balancers distribute traffic across servers</p>
<p>2ï¸âƒ£ Multiple algorithms for different needs:</p>
<p>â€¢ Round Robin â†’ Simple rotation</p>
<p>â€¢ Least Connections â†’ Dynamic balancing</p>
<p>â€¢ Weighted â†’ Different server capabilities</p>
<p>â€¢ IP Hash â†’ Session persistence</p>
<p>3ï¸âƒ£ Health checks prevent routing to dead servers</p>
<p>4ï¸âƒ£ Layer 4 = Fast &amp; simple (TCP/IP)
Layer 7 = Smart &amp; content-aware (HTTP)</p>
<p>5ï¸âƒ£ Load balancers themselves need redundancy!</p>
<p>6ï¸âƒ£ Essential for horizontal scaling</p>
<p>ğŸ¯ One sentence: &quot;Load balancers are traffic directors
that ensure no server gets overwhelmed and every
request reaches a healthy server&quot;</p>
</body>
    </html>