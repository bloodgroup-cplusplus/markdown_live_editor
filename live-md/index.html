
    <html>
      <head><meta charset="UTF-8"><title>Markdown Preview</title></head>
      <body><h2><strong>ğŸ’“ Health Checks and Heartbeats: Is Your System Alive?</strong></h2>
<p>Imagine if your heart stopped beating and nobody noticed for an hour. Terrifying! That's why we have health checks and heartbeats.</p>
<h3><strong>Health Checks: The Wellness Checkup</strong></h3>
<p><strong>What is a Health Check?</strong></p>
<p>The Doctor Visit Analogy:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Doctor asks:</p>
<p>- Are you breathing? (Process running?)</p>
<p>- Is your heart beating? (Database connected?)</p>
<p>- Can you walk? (APIs responding?)</p>
<p>- Do you feel okay? (Error rate normal?)</p>
<p>If all answers are &quot;yes&quot; â†’ Healthy âœ“</p>
<p>If any answer is &quot;no&quot; â†’ Unhealthy âŒ</p>
<p>Your Web Server:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Health check endpoint is usually : GET /health</p>
<p>It returns the status of the server in json format</p>
<pre><code class="language-json">
 {  &quot;status&quot;: &quot;healthy&quot;,
   &quot;checks&quot;:
   {    &quot;database&quot;: &quot;connected&quot;,
     &quot;cache&quot;: &quot;connected&quot;,
     &quot;disk_space&quot;: &quot;45% free&quot;,
     &quot;memory&quot;: &quot;60% used&quot;  },
   &quot;timestamp&quot;: &quot;2025-10-19T14:30:01Z&quot;}
</code></pre>
<p><strong>Types of Health Checks:</strong></p>
<p><strong>1. Shallow Health Check (Quick Check)</strong></p>
<p>Purpose: &quot;Is the server responding?&quot;</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Implementation:
GET /health</p>
<p>Response time: 1-5ms</p>
<p>Checks: Just server process</p>
<p>Example:</p>
<pre><code class="language-js">
 app.get('/health', (req, res) =&gt; {res.status(200).json({ status: 'ok' });});
</code></pre>
<p>Use case:</p>
<p>- Load balancer health check</p>
<p>- Called every 5 seconds</p>
<p>- Must be FAST</p>
<p>Pro: Fast, low overhead</p>
<p>Con: Doesn't check dependencies</p>
<p><strong>2. Deep Health Check (Thorough Check)</strong></p>
<p>Purpose: &quot;Is everything working?&quot;</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Implementation:
GET /health/deep
Response time: 100-500ms
Checks: Everything</p>
<pre><code class="language-js">Example:app.get('/health/deep', async (req, res) =&gt; {

const checks = {
 database: await checkDatabase(),
 redis: await checkRedis(),
 external_api: await checkExternalAPI(),
 disk_space: await checkDiskSpace(),
 memory: await checkMemory()
 };
 const allHealthy = Object.values(checks).every(check =&gt; check.status === 'healthy');
 res.status(allHealthy  200 : 503)
   .json({    status: allHealthy  'healthy' : 'unhealthy',
     checks: checks,   timestamp: new Date().toISOString()
   })})
</code></pre>
<p>Use case:
- Deep health check is used for manual debugging</p>
<p>- It can be used to provide detailed monitoring</p>
<p>- Called less frequently</p>
<p>Pro: It is a more comprehensive form of health check
Con: Slower, more resource intensive</p>
<p><strong>Real Health Check Implementation:</strong></p>
<pre><code class="language-js"> // Production-ready health check

app.get('/health', async (req, res) =&gt; {

  try {
    // Quick checks
    const checks = {
      server: 'up',
      timestamp: new Date().toISOString()
      };
    // Check database (with timeout!)
    try {
      await Promise.race([db.query('SELECT 1'),        timeout(1000) // 1 second max]);
      checks.database = 'connected';
      }
      catch (err) {
        checks.database = 'disconnected';
        return res.status(503).json({        status: 'unhealthy', checks      });
        }
        // Check Redis cache   try {
        await Promise.race([        redis.ping(),        timeout(500)]);
        checks.cache = 'connected';
        } catch (err) {
          checks.cache = 'disconnected';
          // Cache failure is not critical, just warn      logger.warn('Cache health check failed', err);
        }
        // All critical checks passed
        res.status(200).json({      status: 'healthy',      checks
        });}
        catch (err) {
        logger.error('Health check failed', err);    res.status(503).json({
        status: 'unhealthy',      error: err.message    });  }});
        ```

**How Load Balancers Use Health Checks:**

Load Balancer with 3 Servers:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Every 5 seconds, check each server:
```bash

 Time: 14:00:00
Server 1: GET health â†’ 200 OK âœ“
Server 2: GET health â†’ 200 OK âœ“
Server 3: GET /health â†’ 200 OK âœ“
Traffic: Distributed 33% / 33% / 33%
Time: 14:00:05
Server 1: GET /health â†’ 200 OK âœ“
Server 2: GET /health â†’ 503 Unhealthy âŒ
Server 3: GET /health â†’ 200 OK âœ“
Traffic: Distributed 50% / 0% / 50%
(Server 2 removed from rotation\!)
Time: 14:00:10
Server 1: GET /health â†’ 200 OK âœ“
Server 2: GET /health â†’ 200 OK âœ“ (Recovered!)
Server 3: GET /health â†’ 200 OK âœ“
Traffic: Back to 33% / 33% / 33%
</code></pre>
<p><strong>Connection to Previous Topics:</strong> This eliminates SPOF! If one server fails, load balancer detects it via health checks and routes traffic to healthy servers.</p>
<h3><strong>Heartbeats: The Continuous Pulse</strong></h3>
<p><strong>What is a Heartbeat?</strong></p>
<p>The Difference:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Health Check (Pull):</p>
<pre><code>Monitor â”€â”€â”€â”€â”€â”€â”€â”€\&gt; Server

&quot;Are you alive?&quot;

Server responds (or doesn't)
</code></pre>
<p>Heartbeat (Push):</p>
<pre><code>Server â”€â”€â”€â”€â”€â”€â”€â”€\&gt; Monitor

&quot;I'm alive\!&quot;

Server sends regularly
</code></pre>
<p><strong>Real-World Heartbeat Example:</strong></p>
<p>Background Worker Process:</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<pre><code class="language-js"> // Worker sends heartbeat every 30 seconds
setInterval(async () =&gt; {
  try {
    await redis.set(`heartbeat:worker:${workerId}`, Date.now(),
    'EX', 60  // Expires in 60 seconds);
    logger.debug('Heartbeat sent');
    } catch (err) {
      logger.error('Failed to send heartbeat', err);}}, 30000);
    // Monitor checks heartbeats setInterval(async () =&gt; {  const workers = await getWorkerList();
    for (const worker of workers) {
      const heartbeat = await redis.get(`heartbeat:worker:${worker.id}`);
      if (!heartbeat) {
        // No heartbeat received!
        logger.error(`Worker ${worker.id} is dead - no heartbeat`);
        alertOps(`Worker ${worker.id} is down!`);
        restartWorker(worker.id);
        } else {
          const age = Date.now() - parseInt(heartbeat);

          if (age &gt; 45000) {

           // 45 seconds old

            logger.warn(`Worker ${worker.id} heartbeat stale: ${age}ms\`);     }    }  }}, 10000);
            // Check every 10 seconds |
            }


</code></pre>
<p><strong>Heartbeat Patterns:</strong></p>
<p>Pattern 1: Simple Timestamp
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Worker â†’ Redis: SET worker:123:heartbeat 1697712345000</p>
<p>Monitor checks: &quot;Last heartbeat 20 seconds ago&quot; âœ“</p>
<p>Pattern 2: Detailed Status
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Worker â†’</p>
<pre><code class="language-json">
 Monitor: {
worker_id: &quot;123&quot;,
status: &quot;processing&quot;,
current_job: &quot;send_emails&quot;,
jobs_completed: 450,
memory_usage: &quot;45%&quot;,
timestamp: 1697712345000

}
</code></pre>
<p>Monitor knows: What worker is doing right now!</p>
<p>Pattern 3: Dead Man's Switch
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Worker updates key every 30 seconds
Key expires after 60 seconds</p>
<p>If worker dies: Key expires automatically
Monitor: &quot;Key missing = worker dead&quot; âŒ</p>
<h3><strong>Real System Design Example</strong></h3>
<p>Distributed Task Queue System:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Architecture:
[Queue]</p>
<pre><code>        â† Tasks waiting

           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â†“          â†“          â†“
</code></pre>
<p>[Worker 1] [Worker 2] [Worker 3]</p>
<p>Health Checks:</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Each worker exposes: GET /health</p>
<p>Returns:</p>
<pre><code class="language-json"> {  &quot;status&quot;: &quot;healthy&quot;,  &quot;queue_connection&quot;: &quot;connected&quot;, &quot;current_jobs&quot;: 3,  &quot;total_processed&quot;: 1024}
</code></pre>
<p>Load balancer checks every 10 seconds</p>
<p>Heartbeats:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Every 30 seconds, each worker:</p>
<p>Redis SET heartbeat:worker1</p>
<pre><code class="language-json">{
timestamp: 1697712345000,
jobs_in_progress:[{id: &quot;job_123&quot;, started: 1697712300000},
{id: &quot;job_456&quot;, started: 1697712320000}]}
</code></pre>
<p>TTL: 60 seconds (auto-expires if worker dies)</p>
<p>Monitor Dashboard:</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Worker 1: âœ“ Alive (last heartbeat: 15s ago)
Processing 2 jobs</p>
<p>Worker 2: âœ“ Alive (last heartbeat: 8s ago)
Processing 3 jobs</p>
<p>Worker 3: âŒ DEAD (last heartbeat: 75s ago)
ALERT SENT
Auto-restart initiated
Jobs reassigned to Worker 1 and 2</p>
<h3><strong>The Complete Monitoring Stack</strong></h3>
<p>Real Production Setup:</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>Layer 1: Infrastructure Health</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ“ Server CPU, memory, disk</p>
<p>âœ“ Network connectivity</p>
<p>âœ“ Load balancer health checks</p>
<p>Tool: AWS CloudWatch, Prometheus</p>
<p>Layer 2: Application Health</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ“ /health endpoints</p>
<p>âœ“ Error rates</p>
<p>âœ“ Response times</p>
<p>Tool: DataDog APM, New Relic</p>
<p>Layer 3: Business Metrics</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ“ Orders per minute</p>
<p>âœ“ Revenue tracking</p>
<p>âœ“ User signups</p>
<p>Tool: Custom dashboard, Grafana</p>
<p>Layer 4: Logs</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ“ Application logs</p>
<p>âœ“ Error traces</p>
<p>âœ“ Audit logs</p>
<p>Tool: ELK Stack, Splunk</p>
<p>Layer 5: Alerts</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ“ PagerDuty (on-call)</p>
<p>âœ“ Slack notifications</p>
<p>âœ“ Email alerts</p>
<p>Tool: PagerDuty, OpsGenie</p>
<hr>
</body>
    </html>