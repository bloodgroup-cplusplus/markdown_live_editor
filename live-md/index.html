
    <html>
      <head><meta charset="UTF-8"><title>Markdown Preview</title></head>
      <body><hr>
<h2>slug: fundamentals-of-computing
title: Fundamentals Of Computing
readTime: 20 min
orderIndex: 1
premium: false</h2>
<h1>How Computers Work</h1>
<h3><strong>ğŸ¯ Challenge 1: The Mystery Machine</strong></h3>
<p><strong>Imagine this scenario:</strong> You press a key on your keyboard, and within milliseconds, a letter appears on screen. Your computer downloaded a file from across the world. It's playing music, showing videos, and running multiple programs simultaneously.</p>
<p><strong>Pause and think:</strong> How does a machine made of metal, silicon, and electricity perform such complex tasks? What are the essential parts that make this possible?</p>
<hr>
<h3><strong>ğŸ­ The Big Picture: Your Computer is Like a City</strong></h3>
<p><strong>Before diving into technical details, let's understand computers through a familiar analogy:</strong></p>
<p>A COMPUTER = A BUSTLING CITY</p>
<p>ğŸ§  CPU (Central Processing Unit)
= City Government / Mayor's Office
Makes all the decisions and coordinates everything</p>
<p>ğŸ’¾ RAM (Random Access Memory)
= Office Desks / Workspaces
Temporary workspace for active projects</p>
<p>ğŸ’¿ Storage (Hard Drive / SSD)
= City Archives / Libraries
Long-term storage of all information</p>
<p>ğŸ–±ï¸ Input Devices (Keyboard, Mouse)
= Citizens submitting requests
Ways to communicate with the city</p>
<p>ğŸ–¥ï¸ Output Devices (Monitor, Speakers)
= City Announcements / Billboards
How the city communicates back to you</p>
<p>ğŸšŒ Bus / Motherboard
= Roads connecting everything
Pathways for information to flow</p>
<p><strong>Key Insight:</strong> Just like a city needs government, workspace, archives, citizens, and roads to function, your computer needs all these components working together!</p>
<hr>
<h3><strong>ğŸ—ï¸ Interactive Exercise: The Four Essential Components</strong></h3>
<p><strong>Every computer, from smartphone to supercomputer, has four fundamental parts. Let's explore each:</strong></p>
<hr>
<h4><strong>a. THE CPU - The Brain (Decision Maker)</strong></h4>
<p>ğŸ§  WHAT THE CPU DOES:</p>
<p>Think of it as a chef in a kitchen:</p>
<p>Your request: &quot;Make a sandwich&quot;</p>
<p>CPU's job: -</p>
<p><strong>Step 1. Read the recipe  (fetch instruction)</strong></p>
<p><strong>Step 2: Understand what to do (decode instruction)</strong></p>
<p><strong>Step 3: Get ingredients from fridge (fetch data)</strong></p>
<p><strong>Step 4: Execute the steps (process)</strong></p>
<p><strong>Step 5: Serve the sandwich (output result)</strong></p>
<p>The CPU does this BILLIONS of times per second!</p>
<p>Modern CPU (2025):
<img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354297/21_siflv3.png" alt="img1"></p>
<p><strong>Real-world example:</strong></p>
<ul>
<li>Opening Chrome = CPU executes millions of instructions</li>
<li>Playing a game = CPU coordinates graphics, physics, AI</li>
<li>Typing this sentence = CPU processes every keystroke</li>
</ul>
<hr>
<h4><strong>b. RAM - The Workspace (Active Memory)</strong></h4>
<p>ğŸ’¾ WHAT RAM DOES:</p>
<p>Think of it as your desk workspace:</p>
<p>Initially empty desk (Computer off):</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354294/12_dxtgjg.png" alt="img2"></p>
<p>Working desk (Computer on with apps open):</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354295/16_eomwct.png" alt="img3"></p>
<p>Close Chrome (2GB freed):</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354296/17_co8nfo.png" alt="img4"></p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>âš¡ Fast: Access any data in nanoseconds</li>
<li>ğŸ”„ Volatile: Loses everything when powered off</li>
<li>ğŸ’° Expensive: Costs more per GB than storage</li>
<li>ğŸ“ Limited: 8GB, 16GB, 32GB typical sizes</li>
</ul>
<p><strong>Mental model:</strong> RAM is like a desk - fast to access, but cleared when you leave!</p>
<hr>
<h4><strong>c. STORAGE - The Library (Long-term Memory)</strong></h4>
<p>ğŸ’¿ WHAT STORAGE DOES:</p>
<p>Think of it as a library or filing cabinet:</p>
<p>Your 1TB Storage:<img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354297/23_qcewxj.png" alt="img5"></p>
<p>When you open a file:
Storage â†’ Copied to RAM â†’ CPU processes it</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354297/24_xp6bvh.png" alt="img6"></p>
<p>When you save:
CPU â†’ Writes to RAM â†’ Copied to Storage</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354298/25_i56wa8.png" alt="img7"></p>
<p>When you power off:
Storage: âœ… Keeps everything
RAM: âŒ Loses everything</p>
<p><strong>Key characteristics:</strong></p>
<ul>
<li>ğŸ¢ Slower: Milliseconds to access data</li>
<li>ğŸ’¾ Persistent: Keeps data when powered off</li>
<li>ğŸ’µ Cheaper: Much more GB per dollar</li>
<li>ğŸ“¦ Large: 512GB, 1TB, 2TB+ common</li>
</ul>
<p><strong>Mental model:</strong> Storage is like a warehouse - holds lots of stuff, but takes time to retrieve!</p>
<hr>
<h4><strong>d. INPUT/OUTPUT - The Communication System</strong></h4>
<p>ğŸ”„ HOW YOU INTERACT WITH THE COMPUTER:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354299/29_uolrkl.png" alt="img8"></p>
<p><strong>The I/O Journey:</strong></p>
<p>Example: Opening a photo</p>
<p>1. INPUT:
You: Double-click photo.jpg (mouse input)</p>
<p>2. PROCESSING:
CPU: &quot;Open photo.jpg command received&quot;
Storage: Reads photo.jpg (10 MB)
RAM: Loads photo into memory
CPU: Decodes JPEG format</p>
<p>3. OUTPUT:
Monitor: Displays the beautiful image!</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762355306/page34_tnyzcv.png" alt="img9"></p>
<p>Total time: ~100 milliseconds
(Feels instant to you!)</p>
<hr>
<h3><strong>ğŸ® Interactive Journey: Following Data Through the System</strong></h3>
<p><strong>Let's trace what happens when you open Netflix and play a video:</strong></p>
<p>STEP-BY-STEP DATA JOURNEY:</p>
<p>ğŸ“ STEP 1: You click &quot;Play&quot;
Input: Mouse â†’ CPU</p>
<p>[Mouse] â†’ [CPU receives click event]</p>
<p>ğŸ“ STEP 2: CPU processes request
CPU: &quot;User wants to play video&quot;
CPU: &quot;Check if Netflix is in RAM&quot;</p>
<p>[CPU checks] â†’ [RAM has Netflix app âœ“]</p>
<p>ğŸ“ STEP 3: CPU requests video data
CPU â†’ Internet â†’ Netflix servers</p>
<p>[CPU] â†’ [Network card] â†’ [Internet] â†’ ğŸŒ</p>
<p>ğŸ“ STEP 4: Video data arrives
Network â†’ RAM (buffering)</p>
<p>ğŸŒ â†’ [RAM buffer: 00000000 Loading... 10 MB]</p>
<p>ğŸ“ STEP 5: CPU decodes video
RAM â†’ CPU â†’ Processes compressed video
CPU: Decompresses, decodes frames</p>
<p>[Compressed data] â†’ [CPU] â†’ [Raw video frames]</p>
<p>ğŸ“ STEP 6: Play audio
CPU â†’ Sound Card â†’ Speakers</p>
<p>[Audio data] â†’ [Audio processing] â†’ [Speakers ğŸ”Š]</p>
<p>ALL OF THIS HAPPENS 60 TIMES PER SECOND! ğŸ¤¯
(That's 60 frames per second for smooth video)</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354299/31_o6e8we.png" alt="img10"></p>
<p><strong>Mental Model:</strong> It's like a relay race where data is the baton, passed between different parts of the system!</p>
<hr>
<h3><strong>ğŸš¨ Common Misconception: &quot;More RAM = Faster Computer&quot;</strong></h3>
<p><strong>You might think:</strong> &quot;I'll just add more RAM and everything will be faster!&quot;</p>
<p><strong>The Reality:</strong> It's more nuanced!</p>
<p>âŒ WRONG UNDERSTANDING:
&quot;32GB RAM will make my computer 2x faster than 16GB!&quot;</p>
<p>âœ… CORRECT UNDERSTANDING:</p>
<p><strong>Scenario A: You have 8GB RAM</strong>,</p>
<p>You use 7.5GB</p>
<p>i) Your RAM is 95% full</p>
<p>ii) Computer uses slow disk swap</p>
<p>iii) Result: VERY SLOW! ğŸŒ</p>
<p>Now you Upgrade to 16GB:</p>
<p>i) Now your RAM is 47% full</p>
<p>ii) Everything fits in RAM</p>
<p>iii) Result: MUCH FASTER! ğŸš€</p>
<p><strong>Scenario B: You have 16GB RAM, use 8GB</strong></p>
<p>i) Your RAM is 50% full</p>
<p>ii) You have  Plenty of room</p>
<p>iii) Final Result Result: Fast âœ“</p>
<p>Upgrade to 32GB:</p>
<p>i) Your  RAM is 25% full</p>
<p>ii) You have  extra RAM but  just sits empty</p>
<p>iii)  Result: Same speed (no improvement) ğŸ˜</p>
<p><strong>THE RULE:
More RAM helps IF you're running out.
More RAM does nothing IF you already have enough.</strong></p>
<p><strong>Better analogy:</strong></p>
<ul>
<li>RAM = Desk size</li>
<li>Too small desk = Papers fall off, you work on floor (slow!)</li>
<li>Right size desk = Everything fits, you work efficiently</li>
<li>Huge desk = Extra space sits empty, doesn't make you faster</li>
</ul>
<hr>
<h3><strong>ğŸ—ï¸ The Complete System: How It All Works Together</strong></h3>
<p>THE COMPUTER ORCHESTRA</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354299/30_pdnf9u.png" alt="img11"></p>
<hr>
<h3><strong>ğŸ¯ Quick Self-Test: Component Matching</strong></h3>
<p><strong>Match each task to the component primarily responsible:</strong></p>
<p><strong>Tasks:</strong> A. Stores your vacation photos permanently B. Executes the calculation 2 + 2 C. Holds the Netflix app while it's running D. Displays this text you're reading E. Receives your keyboard typing F. Connects all components together</p>
<p><strong>Components:</strong></p>
<ol>
<li>CPU</li>
<li>RAM</li>
<li>Storage</li>
<li>Input Device</li>
<li>Output Device</li>
<li>Motherboard</li>
</ol>
<p><strong>Think about each one...</strong></p>
<hr>
<p><strong>ANSWERS:</strong></p>
<p>A â†’ 3 (Storage) - Permanent photo storage</p>
<p>B â†’ 1 (CPU) - Performs calculations</p>
<p>C â†’ 2 (RAM) - Active apps live here</p>
<p>D â†’ 5 (Output Device - Monitor)</p>
<p>E â†’ 4 (Input Device - Keyboard)</p>
<p>F â†’ 6 (Motherboard) - The circuit board connecting everything</p>
<hr>
<h2><strong>ğŸ”¢ 2. Binary System - The Language of Computers</strong></h2>
<h3><strong>ğŸ¯ Challenge 2: The Light Switch Language</strong></h3>
<p><strong>Scenario:</strong> Imagine you're in a room with only a light switch. You can only communicate using ON and OFF.</p>
<p><strong>Challenge:</strong> How would you represent:</p>
<ul>
<li>Numbers (0, 1, 2, 3...)</li>
<li>Letters (A, B, C...)</li>
<li>Colors (Red, Green, Blue...)</li>
<li>Your vacation photos?</li>
</ul>
<p><strong>Pause and think:</strong> With just ON and OFF, can you really represent everything?</p>
<hr>
<h3><strong>ğŸ’¡ The Binary Revelation</strong></h3>
<p><strong>The Answer:</strong> YES! Computers do exactly this with electricity:</p>
<p>BINARY = The language of ON and OFF</p>
<p>Physical reality in computer:</p>
<p>i) Voltage HIGH (5 volts) = 1 (ON)</p>
<p>ii) Voltage LOW (0 volts)  = 0 (OFF)</p>
<p>Everything in your computer is just:</p>
<p>0 0 1 1 0 1 0 1 1 0 0 1 1 1 0...</p>
<p>But from these simple 0s and 1s, we get:</p>
<p>âœ“ Documents</p>
<p>âœ“ Photos</p>
<p>âœ“ Videos</p>
<p>âœ“ Music</p>
<p>âœ“ Games</p>
<p>âœ“ The entire internet!</p>
<p><strong>Key Insight:</strong> Binary is like Morse code - simple signals that combine to express complex ideas!</p>
<hr>
<h3><strong>ğŸ“ Understanding Binary: From Bits to Terabytes</strong></h3>
<h4><strong>The Hierarchy of Data</strong></h4>
<p>ğŸ” THE BUILDING BLOCKS:</p>
<p>1ï¸âƒ£ BIT (Binary Digit)
Smallest unit of data
Can be: 0 or 1</p>
<p>Example: 1</p>
<p>Real-world: A single light switch</p>
<p>2ï¸âƒ£ BYTE (8 Bits)
Basic unit of storage
8 bits = 1 byte</p>
<p>Example: 01001000</p>
<p>Can represent:</p>
<p>i) Number 0-255</p>
<p>ii) Single letter (H)</p>
<p>iii)  Small instruction</p>
<p>Real-world: Its like 8 light switches in a row</p>
<p>3ï¸âƒ£ KILOBYTE (1,024 Bytes)
1 KB â‰ˆ 1 thousand bytes</p>
<p>Examples:</p>
<p>You have a short email: 2 KB</p>
<pre><code>A small text file: 5 KB
</code></pre>
<p>Tiny image: 10 KB</p>
<p>4ï¸âƒ£ MEGABYTE (1,024 KB)
1 MB â‰ˆ 1 million bytes</p>
<p>Examples:</p>
<p>A high-res photo: 3 MB</p>
<p>A 1 minute MP3 song: 1 MB</p>
<p>A short document: 0.5 MB</p>
<p>A typical app install: 50 MB</p>
<p>5ï¸âƒ£ GIGABYTE (1,024 MB)
1 GB â‰ˆ 1 billion bytes</p>
<p>Examples:</p>
<pre><code>HD movie (1080p): 4 GB

1 hour HD video: 2 GB

Modern video game: 50 GB

1000 songs: 1 GB

Smartphone storage: 128 GB
</code></pre>
<p>6ï¸âƒ£ TERABYTE (1,024 GB)
1 TB â‰ˆ 1 trillion bytes</p>
<p>Examples:</p>
<p>250 HD movies</p>
<p>200,000 songs</p>
<p>500,000 photos</p>
<p>Laptop hard drive: 1-2 TB</p>
<p>External backup drive: 4 TB</p>
<p>7ï¸âƒ£ PETABYTE (1,024 TB)
1 PB â‰ˆ 1 quadrillion bytes</p>
<p>Examples:
Netflix's entire library: ~100 PB</p>
<pre><code>Large company data center: 10 PB

Facebook's daily data: \~4 PB
</code></pre>
<p><strong>The Scale Visualization:</strong></p>
<p>From smallest to largest:</p>
<p>Bit          â€¢                    (one dot)</p>
<p>Byte         â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢             (8 dots)</p>
<p>Kilobyte     [Small paragraph] á¨</p>
<p>Megabyte     [Entire book] ğŸ“–</p>
<p>Gigabyte     [Bookshelf - 100 books]ğŸ“š</p>
<p>Terabyte     [Library - 100 bookshelves] ğŸšªğŸšªğŸšªğŸšªğŸšªğŸšª</p>
<p>Petabyte     [50 Libraries] ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«ğŸ«</p>
<hr>
<h3><strong>ğŸ® Interactive Exercise: Binary to Decimal</strong></h3>
<p><strong>Let's learn how binary represents numbers:</strong></p>
<p>DECIMAL SYSTEM (Base 10):</p>
<p>Positions:  1000s  100s  10s  1s
Number:        2     5    6   3</p>
<p>2Ã—1000 + 5Ã—100 + 6Ã—10 + 3Ã—1 = 2563</p>
<p>We use 10 digits: 0,1,2,3,4,5,6,7,8,9</p>
<p>BINARY SYSTEM (Base 2):</p>
<p>Positions:  8s  4s  2s  1s
Number:      1   0   1   1</p>
<p>1Ã—8 + 0Ã—4 + 1Ã—2 + 1Ã—1 = 11 (decimal)</p>
<p>We use 2 digits: 0, 1</p>
<p>EXAMPLES:</p>
<p>Binary â†’ Decimal:</p>
<p>0001 = 1</p>
<p>0010 = 2</p>
<p>0011 = 3</p>
<p>0100 = 4</p>
<p>0101 = 5</p>
<p>0110 = 6</p>
<p>0111 = 7</p>
<p>1000 = 8</p>
<p>Pattern: Each position doubles!</p>
<p>8  4  2  1</p>
<p>â†“  â†“  â†“  â†“</p>
<p>1  0  1  1  = 8 + 2 + 1 = 11</p>
<p>16 8  4  2  1</p>
<p>â†“  â†“  â†“  â†“  â†“</p>
<p>1  0  0  1  1  = 16 + 2 + 1 = 19</p>
<p><strong>Try these yourself:</strong></p>
<p>Binary 1111 = ?</p>
<p>Binary 1010 = ?</p>
<p>Binary 0110 = ?</p>
<p>(Answers below)</p>
<hr>
<p><strong>ANSWERS:</strong></p>
<p>Binary 1111 = 8 + 4 + 2 + 1 = 15</p>
<p>Binary 1010 = 8 + 0 + 2 + 0 = 10</p>
<p>Binary 0110 = 0 + 4 + 2 + 0 = 6</p>
<hr>
<h3><strong>ğŸ”¤ How Binary Represents Text: ASCII and Unicode</strong></h3>
<p><strong>Ever wonder how computers store letters?</strong></p>
<p>ASCII ENCODING:</p>
<p>Each letter = 1 byte (8 bits)</p>
<p>Letter  â†’  Decimal  â†’  Binary</p>
<p>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p>A     â†’     65    â†’  01000001</p>
<p>B     â†’     66    â†’  01000010</p>
<p>C     â†’     67    â†’  01000011</p>
<p>a     â†’     97    â†’  01100001</p>
<p>b     â†’     98    â†’  01100010</p>
<p>0     â†’     48    â†’  00110000</p>
<p>!     â†’     33    â†’  00100001</p>
<p>Space   â†’     32    â†’  00100000</p>
<p>Example: The word &quot;Hi!&quot;</p>
<p>Hi   !
01001000 01101001 00100001</p>
<p>Total: 3 bytes (24 bits) to store &quot;Hi!&quot;</p>
<p><strong>Your name in binary:</strong></p>
<p>Example: &quot;Bob&quot;</p>
<p>B â†’ 66 â†’ 01000010</p>
<p>o â†’ 111 â†’ 01101111</p>
<p>b â†’ 98 â†’ 01100010</p>
<p>&quot;Bob&quot; = 01000010 01101111 01100010</p>
<p>3 letters = 3 bytes of storage</p>
<hr>
<h3><strong>ğŸ¨ How Binary Represents Colors: RGB</strong></h3>
<p>COLOR ENCODING:</p>
<p>Every pixel on your screen = 3 bytes (24 bits)</p>
<p>Red: 1 byte (0-255)</p>
<p>Green: 1 byte (0-255)</p>
<p>Blue: 1 byte (0-255)</p>
<p>Examples:</p>
<p>i) <strong>Pure Red:</strong></p>
<p>R: 255 (11111111)</p>
<p>G: 0   (00000000)</p>
<p>B: 0   (00000000)</p>
<p>Red pixel</p>
<p>ii) <strong>Pure Green:</strong></p>
<p>R: 0   (00000000)</p>
<p>G: 255 (11111111)</p>
<p>B: 0   (00000000)</p>
<p>Green pixel</p>
<p>iii) <strong>Purple:</strong></p>
<p>R: 128 (10000000)</p>
<p>G: 0   (00000000)</p>
<p>B: 128 (10000000)</p>
<p>Purple pixel</p>
<p>iv) <strong>White:</strong></p>
<p>R: 255 (11111111)</p>
<p>G: 255 (11111111)</p>
<p>B: 255 (11111111)</p>
<p>White pixel</p>
<p>v) <strong>Black:</strong></p>
<p>R: 0   (00000000)</p>
<p>G: 0   (00000000)</p>
<p>B: 0   (00000000)</p>
<p><strong>Black pixel</strong></p>
<p>Your 1920Ã—1080 monitor:
= 2,073,600 pixels Ã— 3 bytes per pixel = 6,220,800 bytes â‰ˆ 6 MB for ONE FRAME!</p>
<p>At 60 FPS:
6 MB Ã— 60 = 360 MB per second!
(This is why graphics cards need fast memory!)</p>
<hr>
<h3><strong>ğŸš¨ Common Misconception: &quot;KB, MB, GB are Exact Thousands&quot;</strong></h3>
<p><strong>You might think:</strong> &quot;1 KB = 1,000 bytes exactly&quot;</p>
<p><strong>The Reality:</strong> It's actually 1,024!</p>
<p><strong>âŒ MARKETING NUMBERS (Decimal):</strong>
1 KB = 1,000 bytes</p>
<p>1 MB = 1,000 KB = 1,000,000 bytes</p>
<p>1 GB = 1,000 MB = 1,000,000,000 bytes</p>
<p>(Hard drive manufacturers use this!)</p>
<p><strong>âœ… COMPUTER NUMBERS (Binary):</strong></p>
<p>1 KB = 1,024 bytes (2Â¹â°)</p>
<p>1 MB = 1,024 KB = 1,048,576 bytes (2Â²â°)</p>
<p>1 GB = 1,024 MB = 1,073,741,824 bytes (2Â³â°)</p>
<p>(Computer systems use this!)</p>
<p><strong>WHY THE DIFFERENCE?</strong></p>
<p>Computers think in powers of 2:</p>
<p>2Â¹â° = 1,024 (close to 1,000)</p>
<p>2Â²â° = 1,048,576 (close to 1 million)</p>
<p>2Â³â° = 1,073,741,824 (close to 1 billion)</p>
<p>THE RESULT:</p>
<p>You buy a &quot;500 GB&quot; hard drive:</p>
<p>Marketing: 500,000,000,000 bytes</p>
<p>Computer sees: 465 GB</p>
<p>You: &quot;Where did my 35 GB go?!&quot; ğŸ˜¡</p>
<p><strong>Reality: Marketing uses 1000, computers use 1024
That's a 7% difference!</strong></p>
<p><strong>Mental model:</strong> Computer storage is like buying a &quot;1 pound&quot; of coffee that's actually 0.93 pounds because they use different measuring systems!</p>
<hr>
<h3><strong>ğŸ¯ The Power of Binary: Everything is Numbers</strong></h3>
<p>WHAT BINARY REPRESENTS:</p>
<p><strong>Text:</strong></p>
<p>&quot;Hello&quot; â†’ 5 bytes</p>
<p>Each letter â†’ specific number â†’ binary</p>
<p><strong>Images:</strong></p>
<p>Photo.jpg â†’ Millions of pixels</p>
<p>Each pixel â†’ RGB values â†’ binary</p>
<p><strong>Videos:</strong></p>
<p>Movie.mp4 â†’ Sequence of images + audio</p>
<p>Each frame â†’ pixels â†’ binary</p>
<p>Audio â†’ sound waves â†’ numbers â†’ binary</p>
<p><strong>Music:</strong></p>
<p>Song.mp3 â†’ Sound wave samples</p>
<p>44,100 samples per second</p>
<p>Each sample â†’ number â†’ binary</p>
<p><strong>Programs:</strong></p>
<p>Chrome.exe â†’ Machine instructions</p>
<p>Each instruction â†’ number â†’ binary</p>
<p>Everything is just different ways of interpreting</p>
<p>patterns of 0s and 1s!</p>
<p><strong>Mind-blowing fact:</strong></p>
<p>This entire article you're reading:
- Every letter: 1 byte</p>
<p>- Total: ~50,000 characters = 50 KB</p>
<p>- In binary: 400,000 bits</p>
<p>- In binary: 400,000 individual 0s and 1s!</p>
<p>01000001 01110010 01100101... (and so on for 50KB!)</p>
<hr>
<h2><strong>ğŸ’¾ 3: Memory Hierarchy - The Speed Pyramid</strong></h2>
<p>Youâ€™ll learn more about storage in the **â€œStorage Fundamentalsâ€**section of the content</p>
<h3><strong>ğŸ¯ Challenge 3: The Library Problem</strong></h3>
<p><strong>Scenario:</strong> You're writing a research paper. Where do you keep your materials?</p>
<p><strong>Option A:</strong> Everything in your brain (instant recall, tiny capacity) <strong>Option B:</strong> Books on your desk (quick to grab, limited space) <strong>Option C:</strong> Books on your bookshelf (walk to get them, more space) <strong>Option D:</strong> Books in the library (drive to get them, unlimited space)</p>
<p><strong>Question:</strong> Which do you use?</p>
<p><strong>The Answer:</strong> ALL OF THEM! You use different storage based on frequency of access and size!</p>
<p><strong>This is exactly how computer memory works!</strong></p>
<hr>
<h3><strong>ğŸ”ï¸ The Memory Pyramid</strong></h3>
<p>THE MEMORY HIERARCHY
(Top = Fastest/Smallest, Bottom = Slowest/Largest)</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762355306/page35_gbmyot.png" alt="img12"></p>
<hr>
<h3><strong>ğŸƒ Understanding the Speed Difference</strong></h3>
<p><strong>Let's make these time scales relatable:</strong></p>
<p>LATENCY HUMANIZED:</p>
<p>If accessing a CPU register took 1 second:</p>
<p>L1 Cache:     3 seconds    (walk to next room)
L2 Cache:     14 seconds   (walk outside)
L3 Cache:     75 seconds   (drive to corner store)
RAM:          5 minutes    (drive across town)
SSD:          4 days       (fly to Europe)
HDD:          1 year       (travel to Saturn)</p>
<p>The difference is MASSIVE!</p>
<hr>
<h3><strong>ğŸ“š Detailed Look at Each Level</strong></h3>
<h4><strong>Level 1: CPU Registers</strong></h4>
<p>ğŸ¯ REGISTERS - The Brain's Scratchpad</p>
<p>Location: Inside the CPU itself
Size: ~16-32 registers Ã— 64 bits = 100-200 bytes
Speed: 0.3 nanoseconds (one CPU cycle)</p>
<p>What they hold:
â”œâ”€ Currently executing instruction
â”œâ”€ Temporary calculation results
â”œâ”€ Memory addresses being accessed
â””â”€ Program counter (what to do next
<img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762355590/3_6_w565ib.png" alt="img13"></p>
<p>â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</p>
<p>Think of it as: Calculator display showing current number</p>
<hr>
<h4><strong>Level 2: L1 Cache</strong></h4>
<p>ğŸš€ L1 CACHE - The CPU's Immediate Memory</p>
<p>Location: On the CPU chip, closest to cores
Size: 32-64 KB per core
Speed: 4 cycles (~1 nanosecond)</p>
<p>Split into two parts:
â”œâ”€ L1 Instruction Cache (code being executed)
â””â”€ L1 Data Cache (data being processed)</p>
<p>Modern CPU (8 cores):
<img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354297/22_aozppg.png" alt="img14"></p>
<p>Think of it as: Items on your desk within arm's reach</p>
<hr>
<h4><strong>Level 3: L2 Cache</strong></h4>
<p>ğŸ’¨ L2 CACHE - The CPU's Short-term Memory</p>
<p>Location: On CPU chip, still very close
Size: 256-512 KB per core
Speed: 12 cycles (~3 nanoseconds)</p>
<p>Holds:
â”œâ”€ Recently used instructions and data
â”œâ”€ Data predicted to be used soon
â””â”€ Overflow from L1 cache</p>
<p>Modern CPU (8 cores):</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762355807/37_vxrhpt.png" alt="img15"></p>
<p>Think of it as: Drawer under your desk</p>
<hr>
<h4><strong>Level 4: L3 Cache</strong></h4>
<p>âš¡ L3 CACHE - Shared CPU Memory</p>
<p>Location: On CPU chip, shared by all cores
Size: 8-64 MB (entire chip)
Speed: 40 cycles (~15 nanoseconds)</p>
<p>Shared resource:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354295/18_nz9ltg.png" alt="img16"></p>
<p>Benefits:
âœ“ Cores can share data efficiently
âœ“ Larger capacity
âœ“ Still much faster than RAM</p>
<p>Think of it as: Bookshelf in your office (shared)</p>
<hr>
<h4><strong>Level 5: RAM (Random Access Memory)</strong></h4>
<p>ğŸ’¾ RAM - Main System Memory</p>
<p>Location: Separate chips on motherboard
Size: 8-128 GB (typical systems)
Speed: 100 nanoseconds</p>
<p>What it holds:
â”œâ”€ Running applications
â”œâ”€ Operating system
â”œâ”€ Open documents
â”œâ”€ Browser tabs
â””â”€ Game data</p>
<p>Example system with 16GB RAM:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354296/15_sb6c2i.png" alt="img17"></p>
<p>Characteristics:
âœ“ Volatile (loses data when powered off)
âœ“ Much larger than cache
âœ“ 100x slower than L3 cache
âœ“ 1,000,000x faster than HDD</p>
<p>Think of it as: Your desk workspace</p>
<hr>
<h4><strong>Level 6: SSD (Solid State Drive)</strong></h4>
<p>ğŸ’¿ SSD - Fast Persistent Storage</p>
<p>Location: Connected via SATA/NVMe
Size: 256 GB - 4 TB
Speed: 100 microseconds (100,000 nanoseconds)</p>
<p>What it holds:
â”œâ”€ Operating system files
â”œâ”€ Programs and applications
â”œâ”€ Documents, photos, videos
â””â”€ Game installations</p>
<p>Characteristics:
âœ“ Persistent (keeps data when off)
âœ“ 1000x slower than RAM
âœ“ No moving parts (silent, durable)
âœ“ More expensive per GB</p>
<p>Speed comparison to HDD:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354296/13_bwainy.png" alt="img18"></p>
<p>Think of it as: Filing cabinet with instant-access drawers</p>
<hr>
<h4><strong>Level 7: HDD (Hard Disk Drive)</strong></h4>
<p>ğŸ’½ HDD - Slow Mechanical Storage</p>
<p>Location: Connected via SATA
Size: 1-20 TB
Speed: 10 milliseconds (10,000,000 nanoseconds)</p>
<p>Physical structure:
<img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354300/32_yns27w.png" alt="img19"></p>
<p>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Characteristics:
âœ“ Persistent
âœ“ Very slow (moving parts!)
âœ“ 100,000x slower than RAM
âœ“ Cheap per GB
âœ“ Large capacity
âœ“ Makes noise, uses power
âœ“ Fragile (hates drops!)</p>
<p>Think of it as: Warehouse storage (takes time to retrieve)</p>
<hr>
<h3><strong>ğŸ® Interactive Journey: The Cache Hunt</strong></h3>
<p><strong>Let's follow what happens when the CPU needs data:</strong></p>
<p>THE DATA RETRIEVAL JOURNEY</p>
<p>CPU needs value at memory address 0x1234:</p>
<p>Step 1: Check L1 Cache
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CPU: &quot;Is address 0x1234 in L1?&quot;
L1: &quot;Checking... NO!&quot; âŒ
Time wasted: 1 nanosecond
Status: L1 CACHE MISS</p>
<p>Step 2: Check L2 Cache
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CPU: &quot;Is address 0x1234 in L2?&quot;
L2: &quot;Checking... NO!&quot; âŒ
Time wasted: 3 nanoseconds (total: 4ns)
Status: L2 CACHE MISS</p>
<p>Step 3: Check L3 Cache
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CPU: &quot;Is address 0x1234 in L3?&quot;
L3: &quot;Checking... NO!&quot; âŒ
Time wasted: 15 nanoseconds (total: 19ns)
Status: L3 CACHE MISS</p>
<p>Step 4: Check RAM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CPU: &quot;Is address 0x1234 in RAM?&quot;
RAM: &quot;Found it! Here's the value: 42&quot; âœ“
Time taken: 100 nanoseconds (total: 119ns)
Status: RAM HIT</p>
<p>Step 5: Update Caches (for next time)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Copy value to L3: Address 0x1234 = 42
Copy value to L2: Address 0x1234 = 42
Copy value to L1: Address 0x1234 = 42</p>
<p>Next time CPU needs 0x1234:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CPU: &quot;Is address 0x1234 in L1?&quot;
L1: &quot;YES! Value = 42&quot; âœ“
Time taken: 1 nanosecond</p>
<p>119x faster the second time! ğŸš€</p>
<hr>
<h3><strong>ğŸ“Š Cache Hit Rates: Why They Matter</strong></h3>
<p>CACHE PERFORMANCE</p>
<p>Typical cache hit rates:
L1 Cache: 95% hit rate
L2 Cache: 80% hit rate (of L1 misses)
L3 Cache: 70% hit rate (of L2 misses)</p>
<p>Example with 1000 memory accesses:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p>950 found in L1 (1 ns each)
= 950 ns</p>
<p>40 found in L2 (3 ns each)
= 120 ns</p>
<p>21 found in L3 (15 ns each)
= 315 ns</p>
<p>10 found in RAM (100 ns each)
= 1000 ns</p>
<p>Total: 2,385 ns for 1000 accesses
Average: 2.4 ns per access!</p>
<p>Without caches (all from RAM):
1000 Ã— 100 ns = 100,000 ns</p>
<p>CACHE MAKES IT 42x FASTER! ğŸš€</p>
<hr>
<h3><strong>ğŸš¨ Common Misconception: &quot;More Cache Always Better&quot;</strong></h3>
<p><strong>You might think:</strong> &quot;I want 1GB of L1 cache!&quot;</p>
<p><strong>The Reality:</strong> Cache size is a careful balance!</p>
<p>âŒ WHY YOU CAN'T HAVE HUGE CACHES:</p>
<p>Problem 1: PHYSICAL SPACE
â”œâ”€ Caches are on the CPU disk
â”œâ”€ Disc size is limited
â””â”€ Larger cache = less room for cores</p>
<p>Problem 2: SPEED TRADEOFF
â”œâ”€ Larger cache = more area to search
â”œâ”€ More area = longer wires
â””â”€ Longer wires = SLOWER access!</p>
<p>Problem 3: COST
â”œâ”€ Cache memory is extremely expensive
â”œâ”€ L1 cache: $1000+ per MB!
â””â”€ RAM: $5 per GB (200,000x cheaper!)</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ… ACTUAL DESIGN:</p>
<p>Modern CPUs use optimal sizes:
L1: 32-64 KB (tiny but INSTANT)
L2: 256-512 KB (small but very fast)
L3: 8-64 MB (larger, shared, still fast)
RAM: 8-128 GB (huge, slower)</p>
<p>Each level is the sweet spot for its purpose!</p>
<p><strong>The Engineering Tradeoff:</strong></p>
<p>Hypothetical 1MB L1 Cache:
âœ“ More hits
âœ“ More data stored
âœ— 10x slower access (defeats the purpose!)
âœ— Takes up space for 2 CPU cores
âœ— Costs thousands of dollars</p>
<p>Actual 32KB L1 Cache:
âœ“ Lightning fast (0.3ns)
âœ“ Affordable
âœ“ Small enough to keep close to core
âœ“ High enough hit rate (95%)</p>
<p>Result: Small but fast beats large but slow!</p>
<hr>
<h3><strong>ğŸ¯ Memory Hierarchy Summary</strong></h3>
<p>THE COMPLETE PICTURE:</p>
<p>Why this hierarchy exists:</p>
<p>ğŸƒ FAST + SMALL + EXPENSIVE
â†•ï¸ Registers: Instant but microscopic
â†•ï¸ L1 Cache: Nearly instant, tiny
â†•ï¸ L2 Cache: Very fast, small
â†•ï¸ L3 Cache: Fast, medium
ğŸ¢ SLOW + LARGE + CHEAP
â†•ï¸ RAM: Decent, large
â†•ï¸ SSD: Slow, huge
â†•ï¸ HDD: Very slow, massive</p>
<p>The Principle: Keep frequently used data close!</p>
<p>LOCALITY OF REFERENCE:</p>
<p>Temporal locality:
&quot;If I accessed this data, I'll likely access it again soon&quot;
â†’ Keep recent data in cache</p>
<p>Spatial locality:
&quot;If I accessed this data, I'll likely access nearby data&quot;
â†’ Load whole cache lines (64 bytes at a time)</p>
<p>This is why caches work so well!</p>
<hr>
<h2><strong>âš™ï¸ 4: CPU Basics - The Brain in Detail</strong></h2>
<h3><strong>ğŸ¯ Challenge 4: The Restaurant Kitchen</strong></h3>
<p><strong>Scenario:</strong> You own a restaurant. You need to serve 100 customers per hour.</p>
<p><strong>Option A:</strong> Hire one incredibly fast chef who cooks 100 meals/hour <strong>Option B:</strong> Hire 10 regular chefs, each cooking 10 meals/hour</p>
<p><strong>Option C:</strong> Hire 4 chefs, but each works on multiple dishes simultaneously</p>
<p><strong>Question:</strong> Which is best? What are the trade-offs?</p>
<p><strong>The Answer:</strong> This is exactly the CPU design problem! Modern CPUs use a combination of all three approaches.</p>
<hr>
<h3><strong>ğŸ§  What is a CPU Core?</strong></h3>
<p>CPU CORE - The Processing Unit</p>
<p>A core is one independent processing unit:</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354301/33_fuuv50.png" alt="img20"></p>
<p>One core can execute ONE instruction
stream at a time.</p>
<hr>
<h3><strong>ğŸ”¢ Multi-Core CPUs: The Team Approach</strong></h3>
<p>EVOLUTION OF CPUS</p>
<p>ğŸ“… YEAR 2000: Single Core</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762356154/38_ffmsoi.png" alt="img21"></p>
<p>Power: 1x
Can do: 1 task at a time</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>ğŸ“… YEAR 2006: Dual Core</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354298/26_rmw1oa.png" alt="img22"></p>
<p>Power: 2x (nearly)
Can do: 2 tasks simultaneously</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>ğŸ“… YEAR 2010: Quad Core</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354298/27_rx20ty.png" alt="img23"></p>
<p>Power: 4x (nearly)
Can do: 4 tasks simultaneously</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>ğŸ“… YEAR 2025: Many Cores</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354298/28_mcqmzg.png" alt="img24"></p>
<p>High-End Desktop: 32 cores
Server CPU: 128+ cores!</p>
<hr>
<h3><strong>ğŸ® Real-World Example: Gaming</strong></h3>
<p><strong>Let's see how cores are used while gaming:</strong></p>
<p>GAME RUNNING ON 8-CORE CPU</p>
<p><img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354295/14_oq93li.png" alt="img25"></p>
<p>Without multiple cores:
One core at 370% = Impossible!
Game would run at &lt;30 FPS</p>
<hr>
<hr>
<h3><strong>â±ï¸ Clock Speed: How Fast the CPU Thinks</strong></h3>
<p>CLOCK SPEED (GHz - Gigahertz)</p>
<p>Clock speed = How many cycles per second</p>
<p>1 Hz = 1 cycle per second
1 KHz = 1,000 cycles per second
1 MHz = 1,000,000 cycles per second
1 GHz = 1,000,000,000 cycles per second</p>
<p>Modern CPU: 3.5 GHz
= 3,500,000,000 cycles per second!</p>
<p>What happens in one cycle?</p>
<p>Simple instruction (add two numbers):
1 cycle = <strong>Fetch, Decode, Execute, Write</strong></p>
<p>Complex instruction (divide):
10-50 cycles</p>
<p>Memory access:
100-300 cycles (cache miss)</p>
<hr>
<hr>
<h3><strong>ğŸ¯ Instruction Execution: The CPU Pipeline</strong></h3>
<p><strong>How does a CPU execute instructions?</strong></p>
<p>THE 4-STAGE PIPELINE</p>
<p>Classic  pipeline:</p>
<p><strong>Stage 1: FETCH</strong>
â”œâ”€ Get instruction from memory
â””â”€ &quot;Retrieve ADD instruction&quot;</p>
<p><strong>Stage 2: DECODE</strong>
â”œâ”€ Figure out what instruction means
â””â”€ &quot;ADD: Add two numbers&quot;</p>
<p><strong>Stage 3: EXECUTE</strong>
â”œâ”€ Perform the operation
â””â”€ &quot;5 + 3 = 8&quot;</p>
<p><strong>Stage 4: WRITE BACK</strong>
â”œâ”€ Write result back
â””â”€ &quot;Register now contains 8&quot;
<img src="https://res.cloudinary.com/dretwg3dy/image/upload/v1762354296/19_rhxfhm.png" alt="img26"></p>
<hr>
<h3><strong>ğŸš¨ Common Misconception: &quot;Higher GHz Always Faster&quot;</strong></h3>
<p><strong>You might think:</strong> &quot;5 GHz CPU must be faster than 3 GHz!&quot;</p>
<p><strong>The Reality:</strong> It's more complex!</p>
<p>âŒ NAIVE COMPARISON:</p>
<p>CPU A: 5.0 GHz, 4 cores
CPU B: 3.5 GHz, 8 cores</p>
<p>Your assumption: A is 43% faster!</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>âœ… REAL-WORLD RESULTS:</p>
<p>Single-threaded task (video game main thread):
â”œâ”€ CPU A: 100 FPS  âœ“ (Winner!)
â””â”€ CPU B: 70 FPS</p>
<p>Multi-threaded task (video rendering):
â”œâ”€ CPU A: 4 min
â””â”€ CPU B: 2.5 min  âœ“ (Winner!)</p>
<p>Why?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p>Single-threaded: Only one core used
â”œâ”€ Higher GHz wins
â””â”€ CPU A's 5 GHz beats B's 3.5 GHz</p>
<p>Multi-threaded: All cores used
â”œâ”€ More cores win
â””â”€ CPU B's 8 cores beat A's 4 cores</p>
<p>â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”</p>
<p>OTHER FACTORS THAT MATTER:</p>
<p>Architecture efficiency:
â”œâ”€ Instructions per cycle (IPC)
â”œâ”€ Some CPUs do more per clock
â””â”€ Example: Apple M3 beats Intel at same GHz!</p>
<p>Cache size:
â”œâ”€ Larger cache = fewer RAM accesses
â””â”€ Can matter more than 0.5 GHz!</p>
<p>Memory speed:
â”œâ”€ CPU waiting for RAM = wasted cycles
â””â”€ Fast RAM helps more than high GHz</p>
<p>Power efficiency:
â”œâ”€ High GHz = high power = thermal throttling
â””â”€ Sustained 4 GHz &gt; burst 5 GHz that throttles</p>
<hr>
<h3><strong>ğŸ® Decision Game: Choose Your CPU</strong></h3>
<p><strong>Scenario: Pick the best CPU for each task:</strong></p>
<p>CPU Options:
A. 4 cores,  5.5 GHz, 16 MB cache, $300
B. 8 cores,  4.0 GHz, 32 MB cache, $350
C. 16 cores, 3.0 GHz, 64 MB cache, $500</p>
<p>Tasks:
1. Gaming (mostly single-threaded)
2. Video editing (multi-threaded)
3. 3D rendering (highly parallel)
4. Office work (light multitasking)
5. Software development (compiling code)</p>
<p><strong>Think about each one...</strong></p>
<hr>
<p><strong>ANSWERS:</strong></p>
<p>1. Gaming â†’ CPU A
Why: High single-thread performance
5.5 GHz handles main game thread best</p>
<p>2. Video editing â†’ CPU B
Why: Good balance
8 cores for timeline processing
4 GHz still decent for playback</p>
<p>3. 3D rendering â†’ CPU C
Why: Maximum parallelism
16 cores render 16 pixels simultaneously
3 GHz sufficient per thread</p>
<p>4. Office work â†’ CPU A or B
Why: Overkill for Office!
Even CPU A is excessive
(Budget option would work fine)</p>
<p>5. Software development â†’ CPU B
Why: Balanced
Compiling uses all cores
High clock helps IDE responsiveness
32MB cache helps with large projects</p>
</body>
    </html>